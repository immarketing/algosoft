
!#include galnet.ccm
!end;
!#include uAlgor.vih
!#include oAlgSetup.vih

!#include iXLSRepBuilder.VIH

!#include alg_5998.vih


!#component "L_DOGOVOR"

!#include consts_alg1.inc
!end;

!#include alg1.vih

!#include selDate.vip

#include Getkau.vih

#component "SZMN"

const

#include GLOCONST.INC
end;

#include agdefines.inc

#include ExtSoot.vih
#include ExtAttr.Vih

#include UserReport.vih

// Для попадания примера в список отчетов -
// раскомментировать конструкцию VipInterface (Implements для Атлантиса 5.1)

#ifdef Atl51
VipInterface UserReport_szmn_doccheck  Implements IUserReport
  Licensed(Free)
;
#else
!VipInterface UserReport_Sample1 Implements IUserReport;
#end

#doc
Пример пользовательского отчета #1
#end
Interface UserReport_szmn_doccheck;

create view;

!-------------------------------------------------------------------------------
// Запуск отчета на выполнение при выборе его из списка отчетов
procedure Run;
begin
  RunInterface('szmn_doccheck')
end;
!-------------------------------------------------------------------------------
// Наименование отчета в списке
function GetReportName: String;
begin
  GetReportName := 'Проверка первичных документов';
end;
!-------------------------------------------------------------------------------
// Наименования групп, в которые входит отчет
// Группа n+1 делается подчиненной группе n
// В данном случае будет иерархия:
// [+] Группа 1
//     [+] Группа 2
//         Отчет 1
function GetGroupName (Level : Word) : String;
begin
  GetGroupName := '';
  case Level of
    1 : GetGroupName := 'Проверка первичных документов';
  end;
end;
!-------------------------------------------------------------------------------
// Приоритет отчета - сортировка внутри группы выполняется сначала
// по приоритету, а затем по наименованию
function GetPriority : Integer;
begin
  GetPriority := 0;
end;
!-------------------------------------------------------------------------------
// ModuleID модулей, в которых будет виден отчет
// '*' - отчет будет виден в любом модуле
function VisibleInModule(Ind : Byte) : String;
begin
  VisibleInModule := '*';
  case Ind of
  end;
end;
!-------------------------------------------------------------------------------
end.

vipInterface #szmn_doccheck licensed(free);

Interface #szmn_doccheck 'СЗ проверка документов' (,hcNoContext,) EscClose, Cyan;
  show at  (0,0,100,30);

#include iCheck_memtbl.vip

#include iCheck_createview.vip
/*
create view
var
  paramSopr   : comp;
  pcSopr      : comp;
  cST_INC     : comp;

  cTBL_SOOTV  : comp;
  cTBL_SOOTV3 : comp;
  TargetBudGroup : comp;

  dtStart, dtFinish : date;
  cFltrCO     : comp;
  sFltrUsDesc : String;

  docToCheck  : byte;
  prbToCheck  : byte;

  useFilter   : byte;

  showUnCor   : byte;

as
select *
  from  KatSopr,
        SpSopr,
        SPECMTR,
        SALDTUNE,
        SALDTUNE st_inc,
        loc_inx,
        FPKATIMP,
        fpco fltrfpco,
        KatMC,
        KatUsl,
        KatDoc
 where ((
!   pcSopr   == KatSopr.nRec and

!   and
    root == KatSopr.nRec and

    (  ((docToCheck and word(1)) > 0 and KatSopr.VidSopr = 111 ) or
      ((docToCheck and word(2)) > 0 and KatSopr.VidSopr = 204 ) or
      ((docToCheck and word(4)) > 0 and KatSopr.VidSopr = 504 ) or
      ((docToCheck and word(8)) > 0 and KatSopr.VidSopr = 602 ) ) and

   KatSopr.nRec == SpSopr.cSopr and
   SpSopr.nrec == SPECMTR.CSPEC and
   SPECMTR.CSALDTUNE == SALDTUNE.NREC and
   cST_INC == st_inc.nRec and

   cTBL_SOOTV == FPKATIMP.nrec and

   cFltrCO == fltrfpco.nRec and

   SpSopr.cMCUsl == katMC.nRec and
   SpSopr.cMCUsl == katUsl.nRec and
   KatSopr.VidSopr == KatDoc.TIDKGAL

 ))
 bounds byDates =  dtStart<<=KatSopr.dsopr(noindex) and dtFinish >>= KatSopr.dsopr (noindex)
 bounds byCO    =  cFltrCO==KatSopr.COTVPODR (noindex)
 bounds byDesc  =  sFltrUsDesc == KatSopr.descr (noindex)
 ;
 */
 parameters paramSopr;

/*
  BROWSE  brplan_KatSopr;
  show at( , , ,3 );
  table KatSopr;
  Fields
    KatSopr.nrec 'KatSopr.nrec':[10],protect;
  end;

  BROWSE  brplan_SpSopr;
  show at( ,4 , ,7);
  table SpSopr;
  Fields
    SpSopr.nrec 'SpSopr.nrec':[10],protect;

  end;


  BROWSE  brplan_SPECMTR;
  show at( ,8 , ,11);
  table SPECMTR;
  Fields
    SPECMTR.nrec 'SPECMTR.nrec': [10],protect;
  end;

  BROWSE  brplan_SALDTUNE;
  show at( ,12 , ,15);
  table SALDTUNE;
  Fields
    SALDTUNE.nrec 'SALDTUNE.nrec':[10],protect;

  end;

  BROWSE  brplan_loc_inx;
  show at( ,16 , ,21);
  table loc_inx;
  Fields
    loc_inx.wSTnRec 'loc_inx.wSTnRec': [10],protect;
    loc_inx.wKau 'loc_inx.wKau': [10],protect;
    loc_inx.inx 'loc_inx.inx': [10],protect;

  end;

  screen  brplan_src;
  show at( ,22 , ,29);
  fields
    pcSopr      : noprotect;
    cTBL_SOOTV  : noprotect;
    cTBL_SOOTV3 : noprotect;
    TargetBudGroup : noprotect;
  buttons
          cmOk,,, 'OGON';
          cmCancel,,, 'F***K OUT';
          cmCmd03,,, 'F***K IN';
  <<
  `Документ для проверки:`           `Таблица соответствий для проблемы 2:`  `Таблица соответствий для проблемы 3`
  .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

  `Целевая группа для проблемы 4:` .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

  <. 1 .>    <.   2   .>  <. 3 .>
  >>
  end;
*/

  function getIndexInSaldTune(stNRec : comp; wCode : word): integer;
  begin

    result := -1;

    if (getFirst loc_inx where (( stNRec == loc_inx.wSTnRec and wCode == loc_inx.wKau)) = tsOK ){
      result := loc_inx.inx;
      exit;
    }

    cST_INC := stNRec;

    if (getFirst st_inc <> tsOK) {
      exit;
    }
    if st_inc.WOBJ = wCode then {
      result := 0;
      insert loc_inx set loc_inx.wSTnRec := stNRec, loc_inx.wKau := wCode, loc_inx.inx := result;
      exit;
    }
    var i : byte;

    for ( i := 1 ; i <= 9 ; i := i + 1){
      if (st_inc.WKAU[i] = wCode) then {
        result := i;
        break;
      }
    }
    insert loc_inx set loc_inx.wSTnRec := stNRec, loc_inx.wKau := wCode, loc_inx.inx := result;
  end;

  create view forCU
  var cSPECMTR : comp;
      wTbl      : word;
  as select * from SPECMTR SPECMTRCU where ((
    forCU.cSPECMTR  == SPECMTRCU.cspec and
    forCU.wTbl      == SPECMTRCU.COTABLE
  ))
  ;

  function getCUAnVal (wT : word; cCU : comp; anCode : word) : comp;
  begin
    forCU.cSPECMTR  := cCU; // позиционируемся на данные целевого учета
    forCU.wTbl      := wT;
    result := 0;
    var cst : comp;
    if (forCU.getFirst SPECMTRCU = tsOK ){
      cST := forCU.SPECMTRCU.CSALDTUNE; // ссылка на настройку целевого учета
      var ind : integer;
      ind := getIndexInSaldTune(cST, anCode);
      if (ind < 0 )then {
        result := 0;
      } else if (ind = 0 ){
        result := forCU.SPECMTRCU.cOBJ;//SALDTUNE.WOBJ;
      } else {
        result := forCU.SPECMTRCU.ckau[ind];//SALDTUNE.WKAU[ind];
      }
    }
  end;



  // проверка на проблему №2
  /*
  20
  5017

  */

#include iCheckPr1.vip
#include iCheckPr2.vip
#include iCheckPr3.vip
#include iCheckPr4.vip
#include iCheckPr5.vip

  form frm  ('iCheck_otchet_v2.out','iCheck_otchet_v2');

  function doCheckCurrent(doPrint : boolean) : boolean;
  begin
    var cnrec : comp;
    var com1  : string;
    var r1    : boolean;

    var com2  : string;
    var r2    : boolean;

    var com3  : string;
    var r3    : boolean;

    var com4  : string;
    var r4    : boolean;

    var com5  : string;
    var r5    : boolean;

    com1  := '';
    r1    := false;

    cnrec := SpSopr.NRec;


    r1 := isCurrentWrong1 (com1);
    r2 := isCurrentWrong2 (com2);
    r3 := isCurrentWrong3 (com3);
    r4 := isCurrentWrong4 (com4);
    r5 := isCurrentWrong5 (com5);

    result := r1 or r2 or /*r3 or */r4 or r5;

    if (not doprint) exit;

    frm.write ( if(r1,1,0) );
    frm.write ( com1 );

    frm.write ( if(r2,1,0) );
    frm.write ( com2 );

    frm.write ( if(r3,1,0) );
    frm.write ( com3 );

    frm.write ( if(r4,1,0) );
    frm.write ( com4 );

    frm.write ( if(r5,1,0) );
    frm.write ( com5 );
    /*
    _loop SPECMTR {
      _loop SALDTUNE {


        //message (1);
        //message (getIndexInSaldTune(SALDTUNE.nRec,22));
      }
    }
    */

  end;

  function doCheckCurrentDO (doPrint : boolean) : boolean;
  begin
    var cnrec : comp;
    var com1  : string;
    var r1    : boolean;

    var com2  : string;
    var r2    : boolean;

    var com3  : string;
    var r3    : boolean;

    var com4  : string;
    var r4    : boolean;

    var com5  : string;
    var r5    : boolean;

    com1  := '';
    r1    := false;

    cnrec := chSpStep.NRec;


    r1 := isCurrentDOWrong1 (com1);
    r2 := isCurrentDOWrong2 (com2);
    r3 := isCurrentDOWrong3 (com3);
    r4 := isCurrentDOWrong4 (com4);
    r5 := isCurrentDOWrong5 (com5);

    result := r1 or r2 or /*r3 or */r4 or r5;

    if (not doprint) exit;

    frm.write ( if(r1,1,0) );
    frm.write ( com1 );

    frm.write ( if(r2,1,0) );
    frm.write ( com2 );

    frm.write ( if(r3,1,0) );
    frm.write ( com3 );

    frm.write ( if(r4,1,0) );
    frm.write ( com4 );

    frm.write ( if(r5,1,0) );
    frm.write ( com5 );

  end;

  procedure BuildUsedVids; forward;

  function doMakeCheckNakl : boolean;
  begin
    var cnt : longint;
    cnt := 0;
    result := false;
    if (getFirst used_vidsopr = tsOK) _loop used_vidsopr {
      if (getFirst KatSopr = tsOK) _loop KatSopr {
        inc(cnt);
        //setVisualHeader ;

        if (not iNextVisual (FormatStr_3 ( 'Формирование отчета | Этап №%d | Шаг №%d | %s',2,cnt, 'Накладная №'+KatSopr.NSopr+' от '+KatSopr.DSopr))
        ) {exit};

        result := true;

        var ew : boolean;
        ew := false;
        _loop SpSopr {
          ew := ew or doCheckCurrent(false);
          if (ew) break;
        }
        //Message ('showUnCor == '+ showUnCor + ''#13'' + 'ew == '+ ew);
        if ( (not ew) and (showUnCor = 1) ) continue;
        //Message (1);

        frm.write ( KatSopr.VidSopr );

        if (getfirst KatDoc = tsOK){
          frm.write ( KatDoc.Name );
        } else {
          frm.write ( 'Вид документа не определен!' );
        }
        frm.write ( String(KatSopr.nRec,20,0) );
        frm.write ( KatSopr.DSopr );
        frm.write ( KatSopr.NSopr );
        frm.write ( KatSopr.Descr );
        frm.write ( KatSopr.SUMMA );
        frm.write ( KatSoprCO.CODE );
        frm.write ( KatSoprCO.Name );

        _loop SpSopr {

          frm.write ( String (SpSopr.nRec,20,0) );
          frm.write ( SpSopr.npp );
          if (SpSopr.prMC =1) {
            if (getfirst katmc = tsOK){
              frm.write ( katmc.Name );
            } else {
              frm.write ( '' );
            }
          } else if (SpSopr.prMC > 1) {
            if (getfirst katUsl = tsOK){
              frm.write ( katUsl.Name );
            } else {
              frm.write ( '' );
            }
          }
          //frm.write ( SpSopr.nRec );
          doCheckCurrent(true);
        }
        frm.putEvent (feBreak);
      }
      frm.putEvent (feBreak);
    }
  end;

  function doMakeCheckDO : boolean;
  begin
    result := false;
    var cnt : longint;
    cnt := 0;

    if (getFirst used_basedocs = tsOK) _loop used_basedocs {
      if (getFirst chBaseDoc = tsOK) _loop chBaseDoc {
        inc(cnt);
        //setVisualHeader ;

        if (not iNextVisual (FormatStr_3 ( 'Формирование отчета | Этап №%d | Шаг №%d | %s',2,cnt, 'ДО №'+chBaseDoc.NODOC+' от '+ chBaseDoc.DDOC))
        ) {exit};

        result := true;
        var ew : boolean;
        ew := false;
        _loop chStepDoc {
          _loop chSpStep {
            ew := ew or doCheckCurrentDO(false);
            if (ew) break;
          }
        }
        if ( (not ew) and (showUnCor = 1) ) continue;

        frm.write ( chBaseDoc.VidDoc );

        case chBaseDoc.VidDoc of
          101 : {
            frm.write ( 'ДО на закупку' );
          }
          111 : {
            frm.write ( 'ДО на предоплату закупок' );
          }
          201 : {
            frm.write ( 'ДО на продажу' );
          }
        end;

        /*
        if (getfirst KatDoc = tsOK){
          frm.write ( KatDoc.Name );
        } else {
          frm.write ( 'Вид документа не определен!' );
        }
        */
        frm.write ( String (chBaseDoc.nRec,20,0 ));
        frm.write ( chBaseDoc.DDOC );
        frm.write ( chBaseDoc.NODOC );
        frm.write ( chBaseDoc.Descr );
        frm.write ( chBaseDoc.SUMMA );
        frm.write ( BaseDocCO.CODE );
        frm.write ( BaseDocCO.Name );


        _loop chStepDoc {
          _loop chSpStep {

            frm.write ( String (chSpStep.nRec,20,0) );
            frm.write ( chSpStep.npp );
            if (chSpStep.prMC =1) {
              if (getfirst chkatmc = tsOK){
                frm.write ( chkatmc.Name );
              } else {
                frm.write ( '' );
              }
            } else if (chSpStep.prMC > 1) {
              if (getfirst chkatUsl = tsOK){
                frm.write ( chkatUsl.Name );
              } else {
                frm.write ( '' );
              }
            }
            //frm.write ( SpSopr.nRec );
            doCheckCurrentDO(true);
          }
        }
        frm.putEvent (feBreak);
      }
      frm.putEvent (feBreak);
    }
  end;

  procedure doMakeCheck (mode : byte);
  begin
    StartNewVisual ( vtRotateVisual   ,
                     vfBreak  + vfConfirm + vfScreenBottom + /* vfThread  + */vfTimer ,
                     'Формирование отчета',
                     100);

    setVisualHeader (FormatStr_3 ( 'Формирование отчета | Этап №%d | Шаг №%d | %s',1,1, 'Формирование списка видов документов'));


    BuildUsedVids;
    //set chStage := 1;

    var hasIteration : boolean;

    hasIteration := false;

    case mode of
      1 : {
        hasIteration := doMakeCheckNakl;
      }
      2 : {
        hasIteration := doMakeCheckDO;
      }
    end;

    //set chStage := 2;
    StopVisual ('',0);


    if (hasIteration or true) {
      frm.ShowFile('');
    }

  end;


  procedure SetTabSootv(ts : comp);
  begin
    cTBL_SOOTV := ts; // для отладки

    if (getfirst FPKATIMP = tsok) {};
    rereadrecord;

    prob2.cFPKATIMP := ts;
  end;

  procedure SetTabSootv3(ts : comp);
  begin
    cTBL_SOOTV3 := ts;

    prob3.cFPKATIMP := ts;

    if (prob3.getfirst FPKATIMPPR3 = tsok) {};
  end;


  procedure handleOK (mode : byte);
  begin
    //message ('OK');

    //message ('docToCheck = '+ docToCheck);

    if cTBL_SOOTV = 0 then {
      //SetTabSootv (comp('0001000000000007h')); // для отладки
      SetTabSootv (comp('013100000000011Bh')); // для отладки
    } else {
      SetTabSootv(cTBL_SOOTV);
    }

    if cTBL_SOOTV3 = 0 then {
      //SetTabSootv3 (comp('0001000000000008h')); // для отладки
      SetTabSootv3 (comp('0001000000000008h')); // для отладки
    }else {
      SetTabSootv3(cTBL_SOOTV3);
    }

    set useFilter := useFilter or 2;

    PopBounds(tnKatSopr);
    PopBounds(tnchBaseDoc);

    BuildUsedVids;

    case mode of
      1 : {
        PopBounds(tnKatSopr);

        AddBounds(tbbyDefSopr);
        if ((useFilter and 1) > 0) then {
          AddBounds(tbbyDatesSopr);
        }

        if ((useFilter and 2) > 0) then {
          //AddBounds(tbbyCOSopr);
        }

        if ((useFilter and 4) > 0) then {
          AddBounds(tbbyDescSopr);
        }
      }
      2 : {
        PopBounds(tnchBaseDoc);

        AddBounds(tbbyDefDO);

        if ((useFilter and 1) > 0) then {
          AddBounds(tbbyDatesDO);
        }

        if ((useFilter and 2) > 0) then {
          //AddBounds(tbbyCODO);
        }

        if ((useFilter and 4) > 0) then {
          AddBounds(tbbyDescDO);
        }
      }
    end;





    /*
    PopBounds(tnKatsopr);

    if ((useFilter and 1) > 0) then {
      AddBounds(tbbyDates);
    }

    if ((useFilter and 2) > 0) then {
      AddBounds(tbbyCO);
    }

    if ((useFilter and 4) > 0) then {
      AddBounds(tbbyDesc);
    }
    */

    doMakeCheck (mode);

    PopBounds(tnKatSopr);
    PopBounds(tnchBaseDoc);

  end;

  procedure savedsk;
  begin
    //Message ( 'savedsk dtStart = '+ );
    SaveMyDsk (dtStart,'iCheckdtStart' )
    SaveMyDsk (dtFinish, 'iCheckdtFinish');
    SaveMyDsk (cFltrCO, 'iCheck_cFltrCO' );
    SaveMyDsk (sFltrUsDesc, 'iCheck_sFltrUsDesc');

    SaveMyDsk (cTBL_SOOTV, 'iCheck_cTBL_SOOTV');
    SaveMyDsk (cTBL_SOOTV3, 'iCheck_cTBL_SOOTV3' );
    SaveMyDsk (TargetBudGroup, 'iCheck_TargetBudGroup');

    SaveMyDsk (docToCheck, 'iCheck_docToCheck');
    SaveMyDsk (BaseDocToCheck, 'iCheck_BaseDocToCheck');

    SaveMyDsk (useFilter, 'iCheck_useFilter');

    SaveMyDsk (showUnCor, 'iCheck_showUnCor');

    SaveMyDsk (cKatImp5, 'iCheck.cKatImp5');
    SaveMyDsk (cKatImp5Group, 'iCheck.cKatImp5Group');

    //SaveMyDsk ('ar', ar);
  end;

  procedure ReadDsk;
  begin
    var dc : boolean;

    dc := true;

    //Message ( 'ReadDsk dtStart = '+ );
    ReadMyDsk (dtStart, 'iCheckdtStart', dc)
    ReadMyDsk (dtFinish, 'iCheckdtFinish', dc);
    ReadMyDsk (cFltrCO, 'iCheck_cFltrCO', dc);
    ReadMyDsk (sFltrUsDesc,'iCheck_sFltrUsDesc', dc);

    ReadMyDsk (cTBL_SOOTV, 'iCheck_cTBL_SOOTV', dc);
    SetTabSootv (cTBL_SOOTV);
    ReadMyDsk (cTBL_SOOTV3, 'iCheck_cTBL_SOOTV3', dc);
    SetTabSootv3 (cTBL_SOOTV3);
    ReadMyDsk (TargetBudGroup, 'iCheck_TargetBudGroup', dc);

    ReadMyDsk (docToCheck, 'iCheck_docToCheck', dc);
    ReadMyDsk (BaseDocToCheck, 'iCheck_BaseDocToCheck', dc);

    ReadMyDsk (useFilter, 'iCheck_useFilter', dc);

    ReadMyDsk (showUnCor, 'iCheck_showUnCor', dc);

    ReadMyDsk (cKatImp5, 'iCheck.cKatImp5', dc);
    ReadMyDsk (cKatImp5Group, 'iCheck.cKatImp5Group', dc);

    //SaveMyDsk ('ar', ar);
  end;

#include iCheck_wnd.vip
  procedure BuildUsedVids;
  begin
    delete all used_vidsopr;
    delete all used_basedocs;

    var l : longint;

    if ((docToCheck and word(1)) > 0) then  {
      l := insert used_vidsopr set used_vidsopr.vidsopr := 111;
    }
    if ((docToCheck and word(2)) > 0) then {
      l := insert used_vidsopr set used_vidsopr.vidsopr := 204;
    }
    if ((docToCheck and word(4)) > 0) then {
      l := insert used_vidsopr set used_vidsopr.vidsopr := 504;
    }
    if ((docToCheck and word(8)) > 0) then {
      l := insert used_vidsopr set used_vidsopr.vidsopr := 602;
    }
    if ((docToCheck and word(16)) > 0) then {
      l := insert used_vidsopr set used_vidsopr.vidsopr := 201;
    }
    if ((docToCheck and word(32)) > 0) then {
      l := insert used_vidsopr set used_vidsopr.vidsopr := 211;
    }

    if ((BaseDocToCheck and word(1)) > 0) then {
      l := insert used_basedocs set used_basedocs.viddoc := 101;
    }
    if ((BaseDocToCheck and word(2)) > 0) then {
      l := insert used_basedocs set used_basedocs.viddoc := 111;
    }
    if ((BaseDocToCheck and word(4)) > 0) then {
      l := insert used_basedocs set used_basedocs.viddoc := 201;
    }
  end;

  procedure handlecmInit;
  begin

    var qwer : F_GetAn::GetKau new;
    liUsedCO := InitMarker( qwer.GetMarkerName(22) ,8,50,10);

    //Message (cmInit);
    dtStart  := cur_date;
    dtFinish := cur_date;

    docToCheck := 1 + 2 + 4 + 8 + 16 + 32;

    baseDocToCheck := 1 + 2 + 4;

    useFilter := 1;

    sFltrUsDesc := sgettune ('USER.DESCR');

    set cKatImp5Group := comp('01310000000001A1h');

    set sExtAttrCO5 := 'NREC каталога проверки СТАТЬИ-ЦО';

    ReadDsk();

    if (cFltrCO <> 0 ) then {
      InitServTXO(0);

      var eCl : C_ExtClass::iExtAttr;

      eCl.CreateAttr (coFPCO, sExtAttrCO5, cgAttrType_Comp );

      //coSetAttr(coFPCO, cFltrCO, sExtAttrCO5, cKatImp5, sKatImp5);
      cKatImp5 := eCl.coGetAttr (coFPCO, cFltrCO, sExtAttrCO5);

      DoneServTXO;
    }

    //if TargetBudGroup = 0 then TargetBudGroup := comp('000000000000000Ah');
    if TargetBudGroup = 0 then TargetBudGroup := comp('00320000000003D1h');
    if cTBL_SOOTV = 0 then SetTabSootv (comp('013100000000011Bh'));

    if paramSopr = 0 then pcSopr := 281474976710687 else pcSopr := paramSopr ;//281474976710659;//281474976710659; // для отладки

    if (getFirst st_inc = tsOK){};
    if (getFirst FPKATIMP = tsOK){};
    if (getFirst fltrfpco = tsOK){};

    if (getFirst used_vidsopr = tsOK){};
    if (getFirst KatSopr = tsOK){};

    if (getFirst used_basedocs = tsOK){};
    if (getFirst chBaseDoc = tsOK){};
    /*
    runwindowmodal (wCheckFltr);

    abort;
    */
  end;

  procedure handleCMPick;
  begin
    case curfield of
      #fltrfpco.name:{
        var cCO : comp;

        cCO := cFltrCO;

        RunInterface('F_FPCATALOG::GetCO', word(cgiPick + cgiMulti + cgiNotEdit + cgiNotClear), comp(0), comp(0), cCO );

        if (cCO <> cFltrCO) then {
          set cFltrCO := cCO;

          if (cFltrCO <> 0 ) then {
            InitServTXO(0);

            var eCl : C_ExtClass::iExtAttr;

            eCl.CreateAttr (coFPCO, sExtAttrCO5, cgAttrType_Comp );

            //coSetAttr(coFPCO, cFltrCO, sExtAttrCO5, cKatImp5, sKatImp5);
            cKatImp5 := eCl.coGetAttr (coFPCO, cFltrCO, sExtAttrCO5);

            DoneServTXO;
          }
        }
      } ;

      #sUsedCO : {
        var qwer : F_GetAn::GetKau new;

        if  (qwer.GetCodeKau(word(cgiPickMult + cgiNotEdit + cgiNotClear ), 22, 0) =0) then {
          //set cPodpGrp := 0;
          exit;
        } else {
          DoneMarker( liUsedCO ,'');
          set liUsedCO := InitMarker(qwer.GetMarkerName(22),8,50,10);

          delete all used_co;

          var i : longint;

          for (i := 0; i<= GetMarkerCount (liUsedCO)-1; inc(i)) {
            var cu : comp;

            GetMarker (liUsedCO, i, cu);

            insert used_co set used_co.cco := cu;
          }
        }
      }

      #sFltrUsDesc: {
        RunInterface('C_COMMON::GetDescr',sFltrUsDesc, '' , true );
      }

      #sKatImp5 : {
        // '01310000000001A1h'
        // '01310000000001A1h'
        //RunInterface('F_FPBUDGET::GetKatImpRel', word(cgiPick), cKatImp5Group, cKatImp5);
        // Каталоги соответствий для проверки СТАТЬЯ-ЦО F_FPBUDGET::VEXTSOOT

        var iImpRel : F_FPBUDGET::vExtSoot;

        if iImpRel.RunKatImpKau(cgiPick,0,0,cKatImp5) then {
          set cKatImp5 := cKatImp5;

          InitServTXO(0);

          var eCl : C_ExtClass::iExtAttr;

          if (cFltrCO <> 0 )then {

            eCl.CreateAttr (coFPCO, sExtAttrCO5, cgAttrType_Comp );

            eCl.coSetAttr(coFPCO, cFltrCO, sExtAttrCO5, cKatImp5, sKatImp5);
          }

          DoneServTXO;
        }

        // GetKatImpName

        //RunInterface('F_TXO::TxoKatImpKau', word(cgiPick), cKatImp5Group, cKatImp5);
      }
    end;
  end;

  HandleEvent
    cmOkNakl : {
      savedsk;
      handleOK (1);
    }

    cmOkDO : {
      savedsk;
      handleOK (2);
    }
    /*
    cmCancel : {
      closewindow (wCheckFltr);
    }
    */

    cmPick : {
      handleCMPick;
    }
    cmInit: {
      handlecmInit;
    };
  end;

  //handleEvent
    /*
    cmPick: {
      case curfield of
        #FPKATIMP.name : {
          //RunInterface ('F_FPBUDGET::GetKatImpRel', 1 );
          //RunInterface ('F_FPBUDGET::GetKatImpRel', 2 );
        }
      end;

    }
    cmDefault: {} ;
    cmOK: {
      //runwindow(wCheckFltr);
      //handleOK;
    }
    cmCmd03 : {
      /*
      var ar : array [1..2] of string;
      ar[1] := 100;
      ar[2] := 200;

      SaveMyDsk ('ar', ar);
    }
      */
  //end;


End.  // interface

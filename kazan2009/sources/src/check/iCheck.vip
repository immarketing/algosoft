
!#include galnet.ccm
!end;
!#include uAlgor.vih
!#include oAlgSetup.vih

!#include iXLSRepBuilder.VIH

!#include alg_5998.vih


!#component "L_DOGOVOR"

!#include consts_alg1.inc
!end;

!#include alg1.vih

!#include selDate.vip

#component "SZMN"

const

#include GLOCONST.INC
end;

#include agdefines.inc


#include UserReport.vih

// Для попадания примера в список отчетов -
// раскомментировать конструкцию VipInterface (Implements для Атлантиса 5.1)

#ifdef Atl51
VipInterface UserReport_szmn_doccheck  Implements IUserReport
  Licensed(Free)
;
#else
!VipInterface UserReport_Sample1 Implements IUserReport;
#end

#doc
Пример пользовательского отчета #1
#end
Interface UserReport_szmn_doccheck;

create view;

!-------------------------------------------------------------------------------
// Запуск отчета на выполнение при выборе его из списка отчетов
procedure Run;
begin
  RunInterface('szmn_doccheck')
end;
!-------------------------------------------------------------------------------
// Наименование отчета в списке
function GetReportName: String;
begin
  GetReportName := 'Проверка первичных документов';
end;
!-------------------------------------------------------------------------------
// Наименования групп, в которые входит отчет
// Группа n+1 делается подчиненной группе n
// В данном случае будет иерархия:
// [+] Группа 1
//     [+] Группа 2
//         Отчет 1
function GetGroupName (Level : Word) : String;
begin
  GetGroupName := '';
  case Level of
    1 : GetGroupName := 'Проверка первичных документов';
  end;
end;
!-------------------------------------------------------------------------------
// Приоритет отчета - сортировка внутри группы выполняется сначала
// по приоритету, а затем по наименованию
function GetPriority : Integer;
begin
  GetPriority := 0;
end;
!-------------------------------------------------------------------------------
// ModuleID модулей, в которых будет виден отчет
// '*' - отчет будет виден в любом модуле
function VisibleInModule(Ind : Byte) : String;
begin
  VisibleInModule := '*';
  case Ind of
  end;
end;
!-------------------------------------------------------------------------------
end.

vipInterface #szmn_doccheck licensed(free);

Interface #szmn_doccheck 'СЗ проверка документов' (,hcNoContext,) EscClose, Cyan;
  show at  (0,0,100,30);

!#include alg5503_memtbls.inc

table struct local loc_inx
(
  wSTnRec : comp,
  wKau : word,
  inx : integer
)
with index
(
  loc_inx01 = wSTnRec+wKau (unique)
)
;

table struct local resSopr
(
  soprNRec : comp
)
with index
(
  resSopr01 = soprNRec (unique)
)
;

table struct local resSpSopr
(
  SpSoprNRec : comp,
  soprNRec : comp,
  res : boolean,
  comments : lvar
)
with index
(
  SpSopr01 = SpSoprNRec (unique)
)
;

#include iCheck_createview.vip
/*
create view
var
  paramSopr   : comp;
  pcSopr      : comp;
  cST_INC     : comp;

  cTBL_SOOTV  : comp;
  cTBL_SOOTV3 : comp;
  TargetBudGroup : comp;

  dtStart, dtFinish : date;
  cFltrCO     : comp;
  sFltrUsDesc : String;

  docToCheck  : byte;
  prbToCheck  : byte;

  useFilter   : byte;

  showUnCor   : byte;

as
select *
  from  KatSopr,
        SpSopr,
        SPECMTR,
        SALDTUNE,
        SALDTUNE st_inc,
        loc_inx,
        FPKATIMP,
        fpco fltrfpco,
        KatMC,
        KatUsl,
        KatDoc
 where ((
!   pcSopr   == KatSopr.nRec and

!   and
    root == KatSopr.nRec and

    (  ((docToCheck and word(1)) > 0 and KatSopr.VidSopr = 111 ) or
      ((docToCheck and word(2)) > 0 and KatSopr.VidSopr = 204 ) or
      ((docToCheck and word(4)) > 0 and KatSopr.VidSopr = 504 ) or
      ((docToCheck and word(8)) > 0 and KatSopr.VidSopr = 602 ) ) and

   KatSopr.nRec == SpSopr.cSopr and
   SpSopr.nrec == SPECMTR.CSPEC and
   SPECMTR.CSALDTUNE == SALDTUNE.NREC and
   cST_INC == st_inc.nRec and

   cTBL_SOOTV == FPKATIMP.nrec and

   cFltrCO == fltrfpco.nRec and

   SpSopr.cMCUsl == katMC.nRec and
   SpSopr.cMCUsl == katUsl.nRec and
   KatSopr.VidSopr == KatDoc.TIDKGAL

 ))
 bounds byDates =  dtStart<<=KatSopr.dsopr(noindex) and dtFinish >>= KatSopr.dsopr (noindex)
 bounds byCO    =  cFltrCO==KatSopr.COTVPODR (noindex)
 bounds byDesc  =  sFltrUsDesc == KatSopr.descr (noindex)
 ;
 */
 parameters paramSopr;

  BROWSE  brplan_KatSopr;
  show at( , , ,3 );
  table KatSopr;
  Fields
    KatSopr.nrec 'KatSopr.nrec':[10],protect;
  end;

  BROWSE  brplan_SpSopr;
  show at( ,4 , ,7);
  table SpSopr;
  Fields
    SpSopr.nrec 'SpSopr.nrec':[10],protect;

  end;


  BROWSE  brplan_SPECMTR;
  show at( ,8 , ,11);
  table SPECMTR;
  Fields
    SPECMTR.nrec 'SPECMTR.nrec': [10],protect;
  end;

  BROWSE  brplan_SALDTUNE;
  show at( ,12 , ,15);
  table SALDTUNE;
  Fields
    SALDTUNE.nrec 'SALDTUNE.nrec':[10],protect;

  end;

  BROWSE  brplan_loc_inx;
  show at( ,16 , ,21);
  table loc_inx;
  Fields
    loc_inx.wSTnRec 'loc_inx.wSTnRec': [10],protect;
    loc_inx.wKau 'loc_inx.wKau': [10],protect;
    loc_inx.inx 'loc_inx.inx': [10],protect;

  end;

  screen  brplan_src;
  show at( ,22 , ,29);
  fields
    pcSopr      : noprotect;
    cTBL_SOOTV  : noprotect;
    cTBL_SOOTV3 : noprotect;
    TargetBudGroup : noprotect;
  buttons
          cmOk,,, 'OGON';
          cmCancel,,, 'F***K OUT';
          cmCmd03,,, 'F***K IN';
  <<
  `Документ для проверки:`           `Таблица соответствий для проблемы 2:`  `Таблица соответствий для проблемы 3`
  .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

  `Целевая группа для проблемы 4:` .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

  <. 1 .>    <.   2   .>  <. 3 .>
  >>
  end;

  function getIndexInSaldTune(stNRec : comp; wCode : word): integer;
  begin

    result := -1;

    if (getFirst loc_inx where (( stNRec == loc_inx.wSTnRec and wCode == loc_inx.wKau)) = tsOK ){
      result := loc_inx.inx;
      exit;
    }

    cST_INC := stNRec;

    if (getFirst st_inc <> tsOK) {
      exit;
    }
    if st_inc.WOBJ = wCode then {
      result := 0;
      insert loc_inx set loc_inx.wSTnRec := stNRec, loc_inx.wKau := wCode, loc_inx.inx := result;
      exit;
    }
    var i : byte;

    for ( i := 1 ; i <= 9 ; i := i + 1){
      if (st_inc.WKAU[i] = wCode) then {
        result := i;
        break;
      }
    }
    insert loc_inx set loc_inx.wSTnRec := stNRec, loc_inx.wKau := wCode, loc_inx.inx := result;
  end;

  create view forCU
  var cSPECMTR : comp;
      wTbl      : word;
  as select * from SPECMTR SPECMTRCU where ((
    cSPECMTR  == SPECMTRCU.cspec and
    wTbl      == SPECMTRCU.COTABLE
  ))
  ;

  function getCUAnVal (wT : word; cCU : comp; anCode : word) : comp;
  begin
    forCU.cSPECMTR  := cCU; // позиционируемся на данные целевого учета
    forCU.wTbl      := wT;
    result := 0;
    var cst : comp;
    if (forCU.getFirst SPECMTRCU = tsOK ){
      cST := forCU.SPECMTRCU.CSALDTUNE; // ссылка на настройку целевого учета
      var ind : integer;
      ind := getIndexInSaldTune(cST, anCode);
      if (ind < 0 )then {
        result := 0;
      } else if (ind = 0 ){
        result := forCU.SPECMTRCU.cOBJ;//SALDTUNE.WOBJ;
      } else {
        result := forCU.SPECMTRCU.ckau[ind];//SALDTUNE.WKAU[ind];
      }
    }
  end;



  // проверка на проблему №2
  /*
  20
  5017

  */

#include iCheckPr1.vip
#include iCheckPr2.vip
#include iCheckPr3.vip
#include iCheckPr4.vip

  form frm  ('iCheck_otchet_v2.out','iCheck_otchet_v2');

  function doCheckCurrent(doPrint : boolean) : boolean;
  begin
    var cnrec : comp;
    var com1  : string;
    var r1    : boolean;

    var com2  : string;
    var r2    : boolean;

    var com3  : string;
    var r3    : boolean;

    var com4  : string;
    var r4    : boolean;

    com1  := '';
    r1    := false;

    cnrec := SpSopr.NRec;


    r1 := isCurrentWrong1 (com1);
    r2 := isCurrentWrong2 (com2);
    r3 := isCurrentWrong3 (com3);
    r4 := isCurrentWrong4 (com4);

    result := r1 or r2 or /*r3 or */r4;

    if (not doprint) exit;

    frm.write ( if(r1,1,0) );
    frm.write ( com1 );

    frm.write ( if(r2,1,0) );
    frm.write ( com2 );

    frm.write ( if(r3,1,0) );
    frm.write ( com3 );

    frm.write ( if(r4,1,0) );
    frm.write ( com4 );
    /*
    _loop SPECMTR {
      _loop SALDTUNE {


        //message (1);
        //message (getIndexInSaldTune(SALDTUNE.nRec,22));
      }
    }
    */

  end;

  function doCheckCurrentDO (doPrint : boolean) : boolean;
  begin
    var cnrec : comp;
    var com1  : string;
    var r1    : boolean;

    var com2  : string;
    var r2    : boolean;

    var com3  : string;
    var r3    : boolean;

    var com4  : string;
    var r4    : boolean;

    com1  := '';
    r1    := false;

    cnrec := chSpStep.NRec;


    r1 := isCurrentDOWrong1 (com1);
    r2 := false ;//isCurrentWrong2 (com2);
    r3 := false ;//isCurrentWrong3 (com3);
    r4 := false ;//isCurrentWrong4 (com4);

    result := r1 or r2 or /*r3 or */r4;

    if (not doprint) exit;

    frm.write ( if(r1,1,0) );
    frm.write ( com1 );

    frm.write ( if(r2,1,0) );
    frm.write ( com2 );

    frm.write ( if(r3,1,0) );
    frm.write ( com3 );

    frm.write ( if(r4,1,0) );
    frm.write ( com4 );

  end;

  procedure doMakeCheck;
  begin
    _loop KatSopr {
      var ew : boolean;
      ew := false;
      _loop SpSopr {
        ew := ew or doCheckCurrent(false);
        if (ew) break;
      }
      //Message ('showUnCor == '+ showUnCor + ''#13'' + 'ew == '+ ew);
      if ( (not ew) and (showUnCor = 1) ) continue;
      //Message (1);

      frm.write ( KatSopr.VidSopr );

      if (getfirst KatDoc = tsOK){
        frm.write ( KatDoc.Name );
      } else {
        frm.write ( 'Вид документа не определен!' );
      }
      frm.write ( KatSopr.nRec );
      frm.write ( KatSopr.DSopr );
      frm.write ( KatSopr.NSopr );
      frm.write ( KatSopr.Descr );
      frm.write ( KatSopr.SUMMA );


      _loop SpSopr {

        frm.write ( SpSopr.nRec );
        frm.write ( SpSopr.npp );
        if (SpSopr.prMC =1) {
          if (getfirst katmc = tsOK){
            frm.write ( katmc.Name );
          } else {
            frm.write ( '' );
          }
        } else if (SpSopr.prMC > 1) {
          if (getfirst katUsl = tsOK){
            frm.write ( katUsl.Name );
          } else {
            frm.write ( '' );
          }
        }
        //frm.write ( SpSopr.nRec );
        doCheckCurrent(true);
      }
      frm.putEvent (feBreak);
    }
    frm.putEvent (feBreak);

    _loop chBaseDoc {
      var ew : boolean;
      ew := false;
      _loop chStepDoc {
        _loop chSpStep {
          ew := ew or doCheckCurrentDO(false);
          if (ew) break;
        }
      }
      if ( (not ew) and (showUnCor = 1) ) continue;

      frm.write ( chBaseDoc.VidDoc );

      case chBaseDoc.VidDoc of
        101 : {
          frm.write ( 'ДО на закупку' );
        }
        111 : {
          frm.write ( 'ДО на предоплату закупок' );
        }
        201 : {
          frm.write ( 'ДО на продажу' );
        }
      end;

      /*
      if (getfirst KatDoc = tsOK){
        frm.write ( KatDoc.Name );
      } else {
        frm.write ( 'Вид документа не определен!' );
      }
      */
      frm.write ( chBaseDoc.nRec );
      frm.write ( chBaseDoc.DDOC );
      frm.write ( chBaseDoc.NODOC );
      frm.write ( chBaseDoc.Descr );
      frm.write ( chBaseDoc.SUMMA );


      _loop chStepDoc {
        _loop chSpStep {

          frm.write ( chSpStep.nRec );
          frm.write ( chSpStep.npp );
          if (chSpStep.prMC =1) {
            if (getfirst chkatmc = tsOK){
              frm.write ( chkatmc.Name );
            } else {
              frm.write ( '' );
            }
          } else if (chSpStep.prMC > 1) {
            if (getfirst chkatUsl = tsOK){
              frm.write ( chkatUsl.Name );
            } else {
              frm.write ( '' );
            }
          }
          //frm.write ( SpSopr.nRec );
          doCheckCurrentDO(true);
        }
      }
      frm.putEvent (feBreak);
    }
    frm.putEvent (feBreak);

    frm.ShowFile('');

  end;


  procedure SetTabSootv(ts : comp);
  begin
    cTBL_SOOTV := ts; // для отладки

    if (getfirst FPKATIMP = tsok) {};
    rereadrecord;

    prob2.cFPKATIMP := ts;
  end;

  procedure SetTabSootv3(ts : comp);
  begin
    cTBL_SOOTV3 := ts;

    prob3.cFPKATIMP := ts;

    if (prob3.getfirst FPKATIMPPR3 = tsok) {};
  end;


  procedure handleOK;
  begin
    //message ('OK');

    //message ('docToCheck = '+ docToCheck);

    if cTBL_SOOTV = 0 then {
      //SetTabSootv (comp('0001000000000007h')); // для отладки
      SetTabSootv (comp('013100000000011Bh')); // для отладки
    } else {
      SetTabSootv(cTBL_SOOTV);
    }

    if cTBL_SOOTV3 = 0 then {
      //SetTabSootv3 (comp('0001000000000008h')); // для отладки
      SetTabSootv3 (comp('0001000000000008h')); // для отладки
    }else {
      SetTabSootv3(cTBL_SOOTV3);
    }

    PopBounds(tnKatsopr);

    if ((useFilter and 1) > 0) then {
      AddBounds(tbbyDates);
    }

    if ((useFilter and 2) > 0) then {
      AddBounds(tbbyCO);
    }

    if ((useFilter and 4) > 0) then {
      AddBounds(tbbyDesc);
    }

    doMakeCheck;

  end;

  procedure savedsk;
  begin
    //Message ( 'savedsk dtStart = '+ );
    SaveMyDsk (dtStart,'iCheckdtStart' )
    SaveMyDsk (dtFinish, 'iCheckdtFinish');
    SaveMyDsk (cFltrCO, 'iCheck_cFltrCO' );
    SaveMyDsk (sFltrUsDesc, 'iCheck_sFltrUsDesc');

    SaveMyDsk (cTBL_SOOTV, 'iCheck_cTBL_SOOTV');
    SaveMyDsk (cTBL_SOOTV3, 'iCheck_cTBL_SOOTV3' );
    SaveMyDsk (TargetBudGroup, 'iCheck_TargetBudGroup');

    SaveMyDsk (docToCheck, 'iCheck_docToCheck');

    SaveMyDsk (useFilter, 'iCheck_useFilter');

    SaveMyDsk (showUnCor, 'iCheck_showUnCor');

    //SaveMyDsk ('ar', ar);
  end;

  procedure ReadDsk;
  begin
    var dc : boolean;

    dc := true;

    //Message ( 'ReadDsk dtStart = '+ );
    ReadMyDsk (dtStart, 'iCheckdtStart', dc)
    ReadMyDsk (dtFinish, 'iCheckdtFinish', dc);
    ReadMyDsk (cFltrCO, 'iCheck_cFltrCO', dc);
    ReadMyDsk (sFltrUsDesc,'iCheck_sFltrUsDesc', dc);

    ReadMyDsk (cTBL_SOOTV, 'iCheck_cTBL_SOOTV', dc);
    SetTabSootv (cTBL_SOOTV);
    ReadMyDsk (cTBL_SOOTV3, 'iCheck_cTBL_SOOTV3', dc);
    SetTabSootv3 (cTBL_SOOTV3);
    ReadMyDsk (TargetBudGroup, 'iCheck_TargetBudGroup', dc);

    ReadMyDsk (docToCheck, 'iCheck_docToCheck', dc);

    ReadMyDsk (useFilter, 'iCheck_useFilter', dc);

    ReadMyDsk (showUnCor, 'iCheck_showUnCor', dc);

    //SaveMyDsk ('ar', ar);
  end;

#include iCheck_wnd.vip

  handleEvent
    cmPick: {
      case curfield of
        #FPKATIMP.name : {
          //RunInterface ('F_FPBUDGET::GetKatImpRel', 1 );
          //RunInterface ('F_FPBUDGET::GetKatImpRel', 2 );
        }
      end;

    }
    cmInit: {

      //Message (cmInit);
      dtStart  := cur_date;
      dtFinish := cur_date;

      docToCheck := 1 + 2 + 4 + 8;

      baseDocToCheck := 1 + 2 + 4;

      useFilter := 1;

      sFltrUsDesc := sgettune ('USER.DESCR');

      ReadDsk();
      //if TargetBudGroup = 0 then TargetBudGroup := comp('000000000000000Ah');
      if TargetBudGroup = 0 then TargetBudGroup := comp('00320000000003D1h');
      if cTBL_SOOTV = 0 then SetTabSootv (comp('013100000000011Bh'));

      if paramSopr = 0 then pcSopr := 281474976710687 else pcSopr := paramSopr ;//281474976710659;//281474976710659; // для отладки

      runwindowmodal (wCheckFltr);

      abort;
    };
    cmDefault: {} ;
    cmOK: {
      runwindow(wCheckFltr);
      //handleOK;
    }
    cmCmd03 : {
      /*
      var ar : array [1..2] of string;
      ar[1] := 100;
      ar[2] := 200;

      SaveMyDsk ('ar', ar);
      */
    }
  end;


End.  // interface

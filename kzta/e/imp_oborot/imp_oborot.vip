#define ComponentVersion
#define licensed_free licensed(free)
#include getkau.vih
#component "KZTA"
interface imp_oborot 'Импорт проводок';
show at (,,66, 7);
table struct tsootv(
  vid: string[10],
  dbf_val: string[20],
  gal_val: comp
) with index (
  i01 = vid + dbf_val
);
const
  vidsootv_zakaz = 'zakaz';
  vidsootv_podr = 'podr';
end;

table struct tob(
  nrec: comp,
  d_schet: string[3],
  d_subschet: string[3],
//  d_nrec: word,
  k_schet: string[3],
  k_subschet: string[3],
//  k_nrec: word,
  sumob: double,
  nodok: string[20],
  datob: date,
  sodpr: string[80],
  podrd: string[20],
  zakaz: string[20],
  czakaz: comp,
  cpodr: comp
) with index (
  i00 = nrec (unique, surrogate),
  i01 = d_schet + d_subschet,
  i02 = zakaz,
  i03 = podrd,
  i04 = datob
);
table struct tgrob(
  datob:date,
  summa: double
) with index (
  i01 = datob (unique)
);
var 
  igetkau:getkau;
  lmarker: longint;
  
create view
var
  cloading_schet: comp;
  cloading_plsch: comp;
  sdbfpath,sootvpath: string;
  cntbadrecs, question_rslt: longint;
  squestion1, squestion2, squestion3, squestion4: string;
  flt_deb,flt_kr,flt_zak,flt_podr: string;
as select cntbadrecs,(scbuhschet.code+' '+scbuhschet.name)(fieldname=sloading_schet),
          if(brob.czakaz>0,if(GetAnyKau(0, scbuhschet.kodtable[1], brob.czakaz), GivenAnName(1), ''), 'Не найдено соотв. Заказ №'+brob.zakaz)(fieldname=szakaz),
          if(brob.cpodr>0,if(GetAnyKau(0, 2, brob.cpodr), GivenAnName(1), ''), 'Не найдено соотв. Подр №'+brob.podrd)(fieldname=spodr),
          * 
from tob, tob brob, tsootv,
     buhschet, buhschet scbuhschet, planssch scplanssch,
     spkau, katpodr,
     tgrob, plpor, soprhoz, oborot
where ((
  cloading_schet == scbuhschet.nrec and
  cloading_plsch == scplanssch.nrec
))
;

procedure recalccntbadrecs; {
  cntbadrecs := 0;
  _loop tob where tob.cpodr=0 or tob.czakaz=0 {
    set cntbadrecs := cntbadrecs + 1;
  }
  rereadrecord(tnNoTable);
}

procedure applyonesootv(_vid,_dbf_val:string;_gal_val:comp); {
  case _vid of
    vidsootv_zakaz: update tob where ((_dbf_val == tob.zakaz)) set tob.czakaz := _gal_val;
    vidsootv_podr : update tob where ((_dbf_val == tob.podrd)) set tob.cpodr := _gal_val;
  end;
}
procedure applysootv; {
  _loop tsootv {
    applyonesootv(tsootv.vid, tsootv.dbf_val, tsootv.gal_val);
  }
}
procedure update_links; {
  startnewvisual(vtRotateVisual, vftimer+vfbreak, 'Обновление', 0);
  _loop tob {
    if getfirst katpodr where ((0 == katpodr.sklad and tob.podrd == katpodr.kod))=tsOk then tob.cpodr := katpodr.nrec;
    if getfirst spkau where ((scbuhschet.kodtable[1] == spkau.kodgrkau and tob.zakaz == spkau.code)) = tsOk then tob.czakaz := spkau.nrec;
    update current tob;
  }
  stopvisual('', 0);
}
procedure setsootv(_vid,_dbf_val:string;_gal_val:comp); {
  if getfirst tsootv where ((_vid == tsootv.vid and _dbf_val == tsootv.dbf_val)) = tsOk {
    update current tsootv set tsootv.gal_val := _gal_val;
  } else {
    insert tsootv set tsootv.vid := _vid, tsootv.dbf_val := _dbf_val, tsootv.gal_val := _gal_val;
  }
}
procedure savesootv(fname:string); {
  if existfile(fname) then deletefile(fname);
  var l: longint;
  l := dbfopen(fname, stcreate);
  dbfaddfield(l,'vid',dbchar,10,0);
  dbfaddfield(l,'dbf_val',dbchar,20,0);
  dbfaddfield(l,'gal_val',dbchar,20,0);
  _loop tsootv {
    dbfputfieldvalue(l,'vid',tsootv.vid);
    dbfputfieldvalue(l,'dbf_val',tsootv.dbf_val);
    dbfputfieldvalue(l,'gal_val',tsootv.gal_val);
    dbfinsertrecord(l);
  }
  dbfclose(l);
}
window wQuestion;
  show at (,,65,9);
  screen scQuestion;
    fields
     squestion1: protect, skip, {font={color=1}};
     squestion2: protect, skip, {font={color=1}};
     squestion3: protect, skip, {font={color=1}};
     squestion4: protect, skip, {font={color=1}};
    buttons
      cmYes, default;
      cmNo;
      cmCancel;
<<
 
 .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  Импортировать?
  
                       <. Да .> <. Нет .> <. Прервать импорт .>
>>
  end;
  handleevent
    cmNo: {
      question_rslt := cmno;
      closewindow(wQuestion);
    }
    cmYes: {
      question_rslt := cmyes;
      closewindow(wQuestion);
    }
    cmcancel: {
      question_rslt := cmcancel;
      closewindow(wQuestion);
    }
  end;
end;
procedure DoImport; {
  startnewvisual(vtRotateVisual, vftimer+vfbreak, 'Импорт проводок', 0);
  var i: integer;
  
  delete all tgrob;
  insert tgrob(datob, summa)
  select tob1.datob, sums.dsum
  from tob tob1,
  (select sum(tob2.sumob)(fieldname=dsum)
   from tob tob2 where ((tob1.datob == tob2.datob))
  )sums
  where FoundMarker(lmarker, tob1.nrec)
  ignore_errors(tsDuplicateKey);
  
  _loop tgrob {
      setvisualheader('Импорт проводок'#13''+tgrob.datob);
      if getfirst plpor where (( 10                                 == plpor.tidk and 
                                 tgrob.datob                        == plpor.DATVIP and 
                                 datetostr(tgrob.datob,'YYYYMMDD' ) == plpor.NODOK)) <> tsOk {
        clearbuffer(#plpor);
        plpor.tidkgal   := 10;
        plpor.tidk      := 10;
        plpor.direct    := 0;
        plpor.NODOK     := datetostr(tgrob.datob,'YYYYMMDD');
        plpor.DESCR     := 'IMP';
        plpor.YEARDOC   := year(tgrob.datob);
        plpor.DATVIP    := tgrob.datob;
        plpor.DATOTS    := plpor.DATVIP;
        plpor.DATOB     := plpor.DATVIP;
        plpor.MODEDOC   := 4098;
        plpor.CHOZOPER  := 281474976710657;
        plpor.sumplat   := tgrob.summa;
        insert current plpor;
      }
      if getfirst soprhoz where (( plpor.tidk == soprhoz.tipdoc and plpor.nrec == soprhoz.csoprdoc )) <> tsOk {
        clearbuffer(#soprhoz);
        soprhoz.datob    := plpor.datob;
        soprhoz.csoprdoc := plpor.nrec;
        soprhoz.tipdoc   := plpor.tidk;
        soprhoz.tidkgal  := plpor.tidkgal;
        soprhoz.nodoc    := plpor.nodok;
        soprhoz.descr    := plpor.descr;
        soprhoz.modedoc  := plpor.modedoc;
        soprhoz.chozoper := plpor.chozoper;
        soprhoz.direct   := plpor.direct;
        soprhoz.summa    := tgrob.summa;
        insert current soprhoz;
      }
      var d_zakaz, d_podr, k_zakaz, k_podr : comp;
      var do_import: boolean;
      _loop tob where ((tgrob.datob == tob.datob)) and FoundMarker(lmarker, tob.nrec) {
        d_zakaz := 0; d_podr := 0; k_zakaz := 0; k_podr := 0;
        if scbuhschet.schet = (scplanssch.kod+tob.d_schet) then {
          d_podr := tob.cpodr;
          d_zakaz := tob.czakaz;
        }       
        if scbuhschet.schet = (scplanssch.kod+tob.k_schet) then {
          k_podr := tob.cpodr;
          k_zakaz := tob.czakaz;
        }
        do_import := true;
        if getfirst oborot where (( plpor.tidk == oborot.tidk and plpor.nrec == oborot.csoprdoc and
                                    cloading_plsch == oborot.cplanssch and
                                   (oborot.dbscheto = tob.d_schet and oborot.subossch = tob.d_subschet and
                                    oborot.krschetk = tob.k_schet and oborot.subschk = tob.k_subschet and
                                    oborot.kodspo = d_podr and oborot.kauos[1] = d_zakaz and
                                    oborot.kodspk = k_podr and oborot.kauks[1] = k_zakaz and 
                                    oborot.sumob = tob.sumob)
                                 )) = tsOk {
          squestion1 := 'В бухсправке №'+plpor.nodok+' от '+plpor.datvip+' найдена импортируемая проводка:';
          squestion2 := 'Д:'+tob.d_schet+'.'+tob.d_subschet+
                        if(d_podr<>'' ,', подр:'+if(GetAnyKau(0,2, d_podr), GivenAnName(1),''),'')+
                        if(d_zakaz<>'',', заказ:'+if(GetAnyKau(0,scbuhschet.kodtable[1], d_zakaz), GivenAnName(1),''),'');
          squestion3 := 'К:'+tob.k_schet+'.'+tob.k_subschet+
                        if(d_podr<>'' ,', подр:'+if(GetAnyKau(0,2, k_podr), GivenAnName(1),''),'')+
                        if(d_zakaz<>'',', заказ:'+if(GetAnyKau(0,scbuhschet.kodtable[1], k_zakaz), GivenAnName(1),''),'');
          squestion4 := 'Сумма: '+tob.sumob;
          runwindowmodal(wQuestion);
          case question_rslt of
            cmNo: do_import := false;
            cmCancel: {
              var _sum: double; _sum := 0;
              _loop oborot where ((plpor.tidk == oborot.tidk and plpor.nrec == oborot.csoprdoc and cloading_plsch == oborot.cplanssch)) {
                _sum := _sum + oborot.sumob;
              }
              update current plpor set plpor.sumplat := _sum;
              update current soprhoz set soprhoz.summa := _sum;
              message('Импорт прерван');
              stopvisual('', 0);
              exit;
            }
          end;
        }
        if do_import {
          clearbuffer(#oborot);
          oborot.tidk      := plpor.tidk;
          oborot.tidkgal   := plpor.tidkgal;
          oborot.csoprdoc  := plpor.nrec;
          oborot.csoprhoz  := soprhoz.nrec;
          oborot.chozoper  := soprhoz.chozoper;
          oborot.cplanssch := cloading_plsch;
          oborot.descr     := plpor.descr;

          oborot.scheto    := scplanssch.kod+tob.d_schet;
          oborot.dbscheto  := tob.d_schet;
          oborot.subossch  := tob.d_subschet;
          oborot.kodspo    := d_podr;
          oborot.kauos[1]  := d_zakaz;
          if getfirst buhschet where (( (scplanssch.kod+tob.d_schet) == buhschet.SCHET and tob.d_subschet == buhschet.subsch)) = tsOk
            for (i:=1;i<=6;inc(i)) { oborot.tblos[i] := buhschet.kodtable[i]; };
          
          oborot.schetk    := scplanssch.kod+tob.k_schet;
          oborot.krschetk  := tob.k_schet;
          oborot.subschk   := tob.k_subschet;
          oborot.kodspk    := k_podr;
          oborot.kauks[1]  := k_zakaz;
          if getfirst buhschet where (( (scplanssch.kod+tob.k_schet) == buhschet.SCHET and tob.k_subschet == buhschet.subsch)) = tsOk
            for (i:=1;i<=6;inc(i)) { oborot.tblks[i] := buhschet.kodtable[i]; };

          oborot.datob     := plpor.datob;
          oborot.dataot    := oborot.datob;
          oborot.nodok     := plpor.nodok;
          oborot.sumob     := tob.sumob;
          oborot.vhprop    := '+';
          insert current oborot;
        }
      }
      var _sum: double; _sum := 0;
      _loop oborot where ((plpor.tidk == oborot.tidk and plpor.nrec == oborot.csoprdoc and cloading_plsch == oborot.cplanssch)) {
        _sum := _sum + oborot.sumob;
      }
      update current plpor set plpor.sumplat := _sum;
      update current soprhoz set soprhoz.summa := _sum;
  }
  stopvisual('',0);
  message('Импорт завершен');
}
window wData 'Данные для импорта';
  screen scData;
    show at(,,,4);
    noTableNavigation;
    fields
      cntbadrecs: skip,left;
    buttons
      cmFindNextBadRec;
      cmImport;
<<
  
 Записи с неопределенным заказом или подразделением: .@@@@@@ <. Найти следующую запись .>
 <. Начать импорт .>
>>
  end;
  browse brData (,,sci1378InsPM);
    show at(,5,,);
    table brob;
    fields
      {font={color=if(FoundMarker(lMarker, brob.nrec),3,0)}};
      brob.datob 'Дата': [8], protect;
      brob.nodok '№ документа': [3], protect;
      brob.d_schet+'.'+brob.d_subschet 'Дебет': [6], protect;
      brob.k_schet+'.'+brob.k_subschet 'Кредит': [6], protect;
      //brob.zakaz 'Заказ': [10], protect;
      szakaz 'Заказ':[20], protect,pickbutton;
      brob.sumob 'Сумма': [8,2], protect;
      //brob.podrd 'Подразделение': [3], protect;
      spodr 'Подразделение':[20], protect,pickbutton;
  end;
  handleevent
  cmMarkUnMark: {
    if (FoundMarker(lMarker, brob.nrec)) { DeleteMarker(lMarker, brob.nrec); }
    else { InsertMarker(lMarker, brob.nrec); }
    if (getnext brob)=tsOk {};
    Rereadrecord(#brob);
  }
  cmSelectAll: {
    ClearMarker(lMarker);
    StartNewVisual(vtRotateVisual, vfTimer+vfBreak, ''#3'Пометка...'#13#3, 1);
    _try {
      pushpos(#brob);
      _loop brob {
        InsertMarker(lMarker, brob.nrec);
        NextVisual;
      }
    } // try
    _except
      on ExUserBreak :
      {
        ClearMarker(lMarker);
      }
    _finally {
      poppos(#brob);
      ReReadRecord(#brob);
      StopVisual('',0);
    }
    Rereadrecord(#brob);
  }
  cmUnSelectAll: {
    ClearMarker(lMarker);
    Rereadrecord(#brob);
  }
  cmImport: {
      DoImport;
    }
    cmFindNextBadRec: {
      var found: boolean;
      var i: integer;
      found := false;
      if getnext brob = tsOk { };
      for (i:=0;i<=1;inc(i)){
        do { 
          if brob.czakaz=0 or brob.cpodr=0 then {
            found := true;
            break;
          }
        } while getnext brob = tsOk;
        if found then break else getfirst brob;
      }
      rereadrecord(#brob);
    }
    cmPick: {
      case curfield of
        #szakaz: {
          var _c: comp;
          _c := brob.czakaz;
          igetkau.GetCodeKau(1, scbuhschet.kodtable[1],_c);
          if _c <> brob.czakaz {
            applyonesootv(vidsootv_zakaz, brob.zakaz, _c);
            setsootv(vidsootv_zakaz,brob.zakaz, _c);
            rereadrecord(#brob);
            recalccntbadrecs;
          }
        }
        #spodr: {
          var _c: comp;
          _c := brob.cpodr;
          igetkau.GetCodeKau(1, 2,_c);
          if _c <> brob.cpodr {
            applyonesootv(vidsootv_podr, brob.podrd, _c);
            setsootv(vidsootv_podr, brob.podrd, _c)
            rereadrecord(#brob);
            recalccntbadrecs;
          }
        }
      end;
    }
    cmDone: {
      savesootv(sootvpath);
      clearmarker(lmarker);
    }
  end;
end;
procedure loaddbf(fname:string); {
  var l,i,cnt, step: longint;
  var s: string;
  SetVisualHeader('Чтение '+fname);
  delete all tob;
  l := dbfopen(fname, stopen);
  cnt := 0; i := 0;
  if dbfgetfirst(l) = 0 then do { cnt := cnt + 1; } while dbfgetnext(l) = 0;
  step := cnt div 100;
  if dbfgetfirst(l) = 0 then do {
    i := i + 1;
    if not nextvisual then break;
    if ( i mod step = 0) then { SetVisualHeader('Чтение '+fname+''#13'Обработка строки '+i+' из '+cnt); }
    clearbuffer(#tob);
    tob.d_subschet := trim(dbfgetfieldvalue(l, 'debet'));
    tob.d_schet := substr(tob.d_subschet,1,2);
    //if getfirst buhschet where (( (scplanssch.kod+tob.d_schet) == buhschet.SCHET and tob.d_subschet == buhschet.subsch)) = tsOk 
    //  tob.d_nrec := buhschet.nrec;
    tob.k_subschet := trim(dbfgetfieldvalue(l, 'kredit'));
    tob.k_schet := substr(tob.k_subschet,1,2);
    //if getfirst buhschet where (( (scplanssch.kod+tob.k_schet) == buhschet.schet and tob.k_subschet == buhschet.subsch)) = tsOk
    //  tob.k_nrec := buhschet.nrec;
    tob.sumob := trim(dbfgetfieldvalue(l, 'sumob'));
    tob.nodok := trim(dbfgetfieldvalue(l, 'nodok'));
    tob.datob := strtodate(trim(dbfgetfieldvalue(l, 'datob')),'YYYYMMDD');
    tob.sodpr := trim(dbfgetfieldvalue(l, 'sodpr'));
    tob.podrd := trim(dbfgetfieldvalue(l, 'podrd'));
    if length(tob.podrd)=1 then tob.podrd := '0'+tob.podrd;
    tob.zakaz := trim(dbfgetfieldvalue(l, 'zakaz'));
    insert current tob;
  } while dbfgetnext(l) = 0;
  dbfclose(l);
}
procedure loadsootv(fname:string); {
  setvisualheader('Чтение файла соответствий');
  var l: longint;
  delete all tsootv;
  l := dbfopen(fname, stopen);
  if dbfgetfirst(l) = 0 then do {
    if not nextvisual then break;
    clearbuffer(#tsootv);
    tsootv.vid := trim(dbfgetfieldvalue(l, 'vid'));
    tsootv.dbf_val := trim(dbfgetfieldvalue(l, 'dbf_val'));
    tsootv.gal_val := trim(dbfgetfieldvalue(l, 'gal_val'));
    insert current tsootv;
  } while dbfgetnext(l) = 0;
  dbfclose(l);
}
screen scmain;
  fields
    sdbfpath: noprotect, pickbutton;
    sootvpath: noprotect, pickbutton;
    scplanssch.name: protect, pickbutton;
    sloading_schet: protect, pickbutton;
  buttons
    cmLoadDBF;
<<

 `Путь к DBF-файлу для импорта` .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 `Путь к DBF-файлу соответствий`.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 `План счетов`      .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 `Загружаемый счет` .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
                                              <. Загрузка DBF .>
>>
end;
function extractfilepath(fname:string):string; {
  result := '';
  var i: integer;
  i := length(fname);
  while i>0 and fname[i]<>'/' and fname[i]<>'\' dec(i);
  if i>2 then result := substr(fname,1,i-1);
}


handleevent
  cmLoadDBF: {
    if not existfile(sdbfpath) then {
      message('Файл "'+sdbfpath+'" не найден');
      selectfield(#sdbfpath);
      exit;
    }
    if cloading_plsch=0 then {
      message('Не указан план счетов');
      selectfield(#scplanssch.name);
      exit;
    }
    if cloading_schet=0 then {
      message('Не указан загружаемый счет');
      selectfield(#sloading_schet);
      exit;
    }
    startnewvisual(vtRotateVisual, vftimer+vfbreak, '', 0);
    loaddbf(sdbfpath);
    delete all tsootv;
    if existfile(sootvpath) loadsootv(sootvpath);
    stopvisual('',0);
    update_links;
    applysootv;
    rereadrecord(#brob);
    recalccntbadrecs;
    runwindow(wData);
  }
  cmPick: {
    case curfield of
      #sdbfpath: {
        sdbfpath := GetFileName('*.dbf','Выберите dbf-файл для импотра');
        if sootvpath = '' then sootvpath := extractfilepath(sdbfpath)+'\sootv.dbf';
        rereadrecord;
      }
      #sootvpath: {
        sootvpath := GetFileName('*.dbf','Выберите dbf-файл соответствий');
        rereadrecord;
      }
      #sloading_schet: {
        if cloading_plsch = 0 {
          message('Сначала укажите план счетов');
          exit;
        }
        var _sch, _subsch: string;
        if runinterface(F_BUHSCHET::GETBUHSCHET,0, cloading_plsch, _sch, _subsch) = cmDefault then 
          if getfirst buhschet where ((_sch==buhschet.schet and _subsch==buhschet.subsch))=tsOk {
            cloading_schet := buhschet.nrec;
            rereadrecord(#scbuhschet);
          }
      }
      #scplanssch.name: {
        var _c: comp; _c := cloading_plsch;
        if runinterface(F_PLANSSCH::GETPLANSSCHEX, _c) = cmDefault then {
          if _c <> cloading_plsch {
            cloading_plsch := _c;
            cloading_schet := 0;
            rereadrecord(#scplanssch);
            rereadrecord(#scbuhschet);
          }
        }
      }
    end;
  }
  cmInit: {
    if not readmydsk(sdbfpath, 'imp_oborot_sdbfpath', false) then sdbfpath := '';
    if not readmydsk(sootvpath, 'imp_oborot_sootvpath', false) then sootvpath := '';
    if not readmydsk(cloading_plsch, 'imp_oborot_cloading_plsch', false) then cloading_plsch := 0;
    if not readmydsk(cloading_schet, 'imp_oborot_cloading_schet', false) then cloading_schet := 0;
    lmarker := initmarker('', 8, 100, 10);
  }
  cmDone: {
    if sootvpath = '' and sdbfpath <> '' then sootvpath := extractfilepath(sdbfpath)+'\sootv.dbf';
    savemydsk(sdbfpath, 'imp_oborot_sdbfpath');
    savemydsk(sootvpath, 'imp_oborot_sootvpath');
    savemydsk(cloading_plsch, 'imp_oborot_cloading_plsch');
    savemydsk(cloading_schet, 'imp_oborot_cloading_schet');
    if sootvpath <> '' then savesootv(sootvpath);
    donemarker(lmarker, '');
  }
end;
end.
.form frm_imp_oborot
.ard
.nameinlist 'КЗТА.Импорт проводок'
.f 'NUL'
.begin
  runinterface(KZTA::imp_oborot);
end.
.endform